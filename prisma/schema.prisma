// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

// generator prismaClassGenerator {
//   provider      = "prisma-class-generator"
//   dryRun        = false
//   output        = "../src/generated/domain"
//   useSwagger    = false
//   makeIndexFile = false
// }

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Consumer {
  id                   String          @id @default(uuid())
  firstName            String?
  lastName             String?
  email                String?         @unique()
  displayEmail         String
  handle               String?         @unique()
  referralCode         String          @unique()
  phone                String?         @unique()
  dateOfBirth          String?         @db.VarChar(10)
  isLocked             Boolean         @default(false)
  isDisabled           Boolean         @default(false)
  createdTimestamp     DateTime?       @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp     DateTime?       @updatedAt // Marking optional so we don't need to set in tests
  socialSecurityNumber String?
  referredByID         String?
  referredBy           Consumer?       @relation("ReferredBy", fields: [referredByID], references: [id])
  referredConsumers    Consumer[]      @relation("ReferredBy")
  address              Address?
  verificationData     KYC?
  cryptoWallets        CryptoWallet[]
  paymentMethods       PaymentMethod[]
  circleAccountData    Circle?
  Transaction          Transaction[]

  @@index([email])
  @@index([handle])
  @@index([phone])
  @@index([referredByID])
  @@index([referralCode])
}

model Address {
  id          String   @id @default(uuid())
  streetLine1 String
  streetLine2 String?
  city        String
  countryCode String   @db.VarChar(3)
  regionCode  String
  postalCode  String
  consumer    Consumer @relation(fields: [consumerID], references: [id], onDelete: Cascade)
  consumerID  String   @unique()
}

model KYC {
  id                            String                     @id @default(uuid())
  kycCheckReference             String?
  documentCheckReference        String?
  provider                      KYCProvider                @default(SARDINE)
  riskRating                    String?
  isSuspectedFraud              Boolean                    @default(false)
  kycCheckStatus                KYCStatus                  @default(NOT_SUBMITTED)
  documentVerificationStatus    DocumentVerificationStatus @default(REQUIRED)
  documentVerificationTimestamp DateTime?
  kycVerificationTimestamp      DateTime?
  sanctionLevel                 String?
  riskLevel                     String?
  consumer                      Consumer                   @relation(fields: [consumerID], references: [id], onDelete: Cascade)
  consumerID                    String                     @unique()
}

model CryptoWallet {
  id               String       @id @default(uuid())
  address          String       @unique()
  createdTimestamp DateTime?    @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime?    @updatedAt // Marking optional so we don't need to set in tests
  name             String?
  chainType        String?
  isEVMCompatible  Boolean?
  status           WalletStatus @default(PENDING)
  riskScore        Float?
  consumer         Consumer     @relation(fields: [consumerID], references: [id], onDelete: Cascade)
  consumerID       String

  @@index([address])
}

model PaymentMethod {
  id               String              @id @default(uuid())
  name             String?
  type             PaymentMethodType
  paymentToken     String              @unique()
  createdTimestamp DateTime?           @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime?           @updatedAt // Marking optional so we don't need to set in tests
  paymentProvider  PaymentProvider
  status           PaymentMethodStatus
  isDefault        Boolean             @default(false)
  imageUri         String?
  consumer         Consumer            @relation(fields: [consumerID], references: [id], onDelete: Cascade)
  consumerID       String
  cardData         Card?
  achData          ACH?

  @@index([paymentToken])
}

model Card {
  id              String        @id @default(uuid())
  cardType        String?
  scheme          String?
  first6Digits    String
  last4Digits     String
  authCode        String?
  authReason      String?
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodID], references: [id], onDelete: Cascade)
  paymentMethodID String        @unique()
}

model ACH {
  id              String        @id @default(uuid())
  accountID       String
  accessToken     String
  itemID          String
  mask            String
  accountType     String
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodID], references: [id], onDelete: Cascade)
  paymentMethodID String        @unique()
}

model Circle {
  id               String    @id
  createdTimestamp DateTime? @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime? @updatedAt // Marking optional so we don't need to set in tests
  walletID         String    @unique()
  consumer         Consumer  @relation(fields: [consumerID], references: [id], onDelete: Cascade)
  consumerID       String    @unique()

  @@index([consumerID])
}

model Otp {
  id                     String       @id @default(uuid())
  otpIdentifier          String
  createdTimestamp       DateTime?    @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp       DateTime?    @updatedAt // Marking optional so we don't need to set in tests
  otp                    Int
  otpExpirationTimestamp DateTime
  identityType           IdentityType

  @@unique([otpIdentifier, identityType], name: "uniqueIdentifier")
  @@index([otpIdentifier, identityType])
  @@index([otp])
}

model LimitProfile {
  id                 String               @id @default(uuid())
  name               String
  daily              Float?
  weekly             Float?
  monthly            Float
  maxTransaction     Float
  minTransaction     Float
  unsettledExposure  Float?
  LimitConfiguration LimitConfiguration[]
  createdTimestamp   DateTime?            @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp   DateTime?            @updatedAt // Marking optional so we don't need to set in tests
}

model LimitConfiguration {
  id                        String             @id @default(uuid())
  isDefault                 Boolean            @default(false)
  priority                  Int
  profile                   LimitProfile       @relation(fields: [profileID], references: [id], onDelete: Cascade)
  profileID                 String
  transactionType           TransactionType?
  minProfileAge             Int?
  minBalanceInWallet        Float?
  minTotalTransactionAmount Float?
  paymentMethodType         PaymentMethodType?
  createdTimestamp          DateTime?          @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp          DateTime?          @updatedAt // Marking optional so we don't need to set in tests
}

model Transaction {
  id               String    @id @default(uuid())
  transactionRef   String    @unique()
  workflowName     String
  consumer         Consumer  @relation(fields: [consumerID], references: [id], onDelete: Cascade)
  consumerID       String
  status           String    @default("PENDING")
  debitCurrency    String?
  creditCurrency   String?
  debitAmount      Float?
  creditAmount     Float?
  exchangeRate     Float?
  createdTimestamp DateTime? @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime? @updatedAt // Marking optional so we don't need to set in tests
}

model Token {
  id               String    @id
  tokenType        TokenType
  expiryTime       DateTime?
  userID           String
  isUsed           Boolean   @default(false)
  createdTimestamp DateTime? @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime? @updatedAt // Marking optional so we don't need to set in tests
}

model Admin {
  id               String    @id @default(uuid())
  name             String?
  email            String    @unique()
  role             String
  createdTimestamp DateTime? @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime? @updatedAt // Marking optional so we don't need to set in tests

  @@index([email])
}

model Verification {
  id               String    @id @default(uuid())
  userID           String?
  transactionID    String?   @unique()
  createdTimestamp DateTime? @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime? @updatedAt // Marking optional so we don't need to set in tests

  @@index([userID])
}

model CreditCardBIN {
  id        String  @id @default(uuid())
  issuer    String?
  bin       String  @unique()
  type      String
  network   String
  mask      String?
  supported String
  digits    Int
  cvvDigits Int

  createdTimestamp DateTime? @default(now()) // Marking optional so we don't need to set in tests
  updatedTimestamp DateTime? @updatedAt // Marking optional so we don't need to set in tests

  @@index([bin])
  @@index([supported])
}

enum IdentityType {
  CONSUMER
  NOBA_ADMIN
}

enum KYCStatus {
  NOT_SUBMITTED
  PENDING
  APPROVED
  FLAGGED
  REJECTED
}

enum DocumentVerificationStatus {
  NOT_REQUIRED
  REQUIRED
  PENDING
  APPROVED
  REJECTED
  REJECTED_DOCUMENT_REQUIRES_RECAPTURE
  REJECTED_DOCUMENT_POOR_QUALITY
  REJECTED_DOCUMENT_INVALID_SIZE_OR_TYPE
  LIVE_PHOTO_VERIFIED
}

enum WalletStatus {
  PENDING
  FLAGGED
  REJECTED
  APPROVED
  DELETED
}

enum PaymentMethodType {
  CARD
  ACH
}

enum PaymentProvider {
  CHECKOUT
}

enum PaymentMethodStatus {
  FLAGGED
  REJECTED
  APPROVED
  UNSUPPORTED
  DELETED
}

enum KYCProvider {
  SARDINE
}

enum TransactionType {
  NOBA_WALLET
}

enum TokenType {
  REFRESH_TOKEN
}
