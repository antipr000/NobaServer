import { Injectable, BadRequestException, Inject } from "@nestjs/common";
import Checkout from "checkout-sdk-node";
import { WINSTON_MODULE_PROVIDER } from "nest-winston";
import { Logger } from "winston";
import { CheckoutConfigs } from "../../config/configtypes/CheckoutConfigs";
import { CHECKOUT_CONFIG_KEY } from "../../config/ConfigurationUtils";
import { CustomConfigService } from "../../core/utils/AppConfigModule";
import { CheckoutPaymentStatus } from "./domain/CheckoutTypes";
import { AddPaymentMethodDTO } from "../consumer/dto/AddPaymentMethodDTO";
import { PspAddPaymentMethodResponse } from "./domain/PspAddPaymentMethodResponse";
import { PspPaymentResponse } from "./domain/PspPaymentResponse";

@Injectable()
export class CheckoutService {
  private readonly checkoutApi: Checkout;
  private readonly checkoutConfigs: CheckoutConfigs;

  @Inject(WINSTON_MODULE_PROVIDER)
  private readonly logger: Logger;

  constructor(private configService: CustomConfigService) {
    this.checkoutConfigs = configService.get<CheckoutConfigs>(CHECKOUT_CONFIG_KEY);
    this.checkoutApi = new Checkout(this.checkoutConfigs.secretKey, {
      pk: this.checkoutConfigs.publicKey,
    });
  }

  public async createConsumer(email: string): Promise<string> {
    try {
      const checkoutCustomer = await this.checkoutApi.customers.create({
        email: email,
        metadata: {
          coupon_code: this.configService.get<CheckoutConfigs>(CHECKOUT_CONFIG_KEY).couponCode,
          partner_id: this.configService.get<CheckoutConfigs>(CHECKOUT_CONFIG_KEY).partnerId,
        },
      });

      return checkoutCustomer["id"];
    } catch (e) {
      if (e.body["error_codes"].filter(errorCode => errorCode === "customer_email_already_exists").length > 0) {
        // existing customer
        const checkoutCustomer = await this.checkoutApi.customers.get(email);
        return checkoutCustomer["id"];
      } else {
        throw new BadRequestException("Failed to create checkout customer");
      }
    }
  }

  public async addPaymentMethod(
    paymentMethod: AddPaymentMethodDTO,
    checkoutCustomerID: string,
  ): Promise<PspAddPaymentMethodResponse> {
    try {
      // To add payment method, we first need to tokenize the card
      // Token is only valid for 15 mins
      const token = await this.checkoutApi.tokens.request({
        type: "card",
        number: paymentMethod.cardDetails.cardNumber,
        expiry_month: paymentMethod.cardDetails.expiryMonth,
        expiry_year: paymentMethod.cardDetails.expiryYear,
        cvv: paymentMethod.cardDetails.cvv,
      });

      // Now create instrument
      const instrument = await this.checkoutApi.instruments.create({
        // infered type "token",
        token: token["token"], // Generated by Checkout.Frames
        customer: {
          id: checkoutCustomerID,
        },
      });
      console.log(instrument);
      return {
        instrumentID: instrument["id"],
        scheme: instrument["scheme"],
        bin: instrument["bin"],
        issuer: instrument["issuer"] ?? "",
        cardType: instrument["card_type"],
      };
    } catch (err) {
      this.logger.error(`Failed to add card card: ${err}`);
      throw new BadRequestException({ message: "Failed to add card" });
    }
  }

  public async getPaymentMethod(paymentMethodID: string): Promise<PspAddPaymentMethodResponse> {
    const paymentMethodResponse = await this.checkoutApi.instruments.get(paymentMethodID);

    return {
      instrumentID: paymentMethodID,
      scheme: paymentMethodResponse["scheme"],
      bin: paymentMethodResponse["bin"],
      issuer: paymentMethodResponse["issuer"] ?? "",
      cardType: paymentMethodResponse["card_type"],
    };
  }

  public async makePayment(
    amount: number,
    currency: string,
    paymentMethodId: string,
    transactionId: string,
  ): Promise<PspPaymentResponse> {
    let checkoutResponse;
    try {
      checkoutResponse = await this.checkoutApi.payments.request(
        {
          amount: amount,
          currency: currency,
          source: {
            type: "id",
            id: paymentMethodId,
          },
          description: "Noba Customer Payment at UTC " + Date.now(),
          metadata: {
            order_id: transactionId,
          },
        },
        /*idempotencyKey=*/ transactionId,
      );
      return {
        id: checkoutResponse["id"],
        response_code: checkoutResponse["response_code"],
        response_summary: checkoutResponse["response_summary"],
        risk: {
          flagged: checkoutResponse["risk"]["flagged"],
        },
        bin: checkoutResponse["source"]["bin"],
      };
    } catch (err) {
      this.logger.error(
        `Exception while requesting checkout payment for transaction id ${transactionId}: ${err.message}`,
      );
      throw err;
    }
  }

  public async getPaymentDetails(paymentId: string): Promise<CheckoutPaymentStatus> {
    try {
      const payment = await this.checkoutApi.payments.get(paymentId);
      const status: CheckoutPaymentStatus = payment.status;
      return status;
    } catch (err) {
      throw new Error("Error while checking payment status from payment id " + paymentId + " " + err);
    }
  }

  public async removePaymentMethod(paymentMethodId: string): Promise<void> {
    await this.checkoutApi.instruments.delete(paymentMethodId);
  }
}
