import { Injectable, BadRequestException, Inject } from "@nestjs/common";
import Checkout from "checkout-sdk-node";
import { Logger } from "winston";
import { CheckoutConfigs } from "../../config/configtypes/CheckoutConfigs";
import { CHECKOUT_CONFIG_KEY } from "../../config/ConfigurationUtils";
import { CustomConfigService } from "../../core/utils/AppConfigModule";
import { CheckoutPaymentStatus, WorkflowMetadata } from "./domain/CheckoutTypes";
import { AddPaymentMethodDTO, PaymentType } from "../consumer/dto/AddPaymentMethodDTO";
import { PspAddPaymentMethodResponse } from "./domain/PspAddPaymentMethodResponse";
import { PspACHPaymentResponse, PspCardPaymentResponse } from "./domain/PspPaymentResponse";
import axios from "axios";
import { WINSTON_MODULE_PROVIDER } from "nest-winston";
import { Consumer } from "../consumer/domain/Consumer";

@Injectable()
export class CheckoutClient {
  private readonly checkoutApi: Checkout;
  private readonly checkoutConfigs: CheckoutConfigs;

  constructor(
    private configService: CustomConfigService,
    @Inject(WINSTON_MODULE_PROVIDER) private readonly logger: Logger,
  ) {
    this.checkoutConfigs = configService.get<CheckoutConfigs>(CHECKOUT_CONFIG_KEY);
    this.checkoutApi = new Checkout(this.checkoutConfigs.secretKey, {
      pk: this.checkoutConfigs.publicKey,
    });
  }

  public async createConsumer(email: string): Promise<string> {
    try {
      const checkoutCustomer = await this.checkoutApi.customers.create({
        email: email,
        metadata: {
          coupon_code: this.configService.get<CheckoutConfigs>(CHECKOUT_CONFIG_KEY).couponCode,
          partner_id: this.configService.get<CheckoutConfigs>(CHECKOUT_CONFIG_KEY).partnerId,
        },
      });

      return checkoutCustomer["id"];
    } catch (e) {
      if (e.body["error_codes"].filter(errorCode => errorCode === "customer_email_already_exists").length > 0) {
        // existing customer
        const checkoutCustomer = await this.checkoutApi.customers.get(email);
        return checkoutCustomer["id"];
      } else {
        throw new BadRequestException("Failed to create checkout customer");
      }
    }
  }

  public async addCreditCardPaymentMethod(
    paymentMethod: AddPaymentMethodDTO,
    checkoutCustomerID: string,
  ): Promise<PspAddPaymentMethodResponse> {
    if (paymentMethod.type !== PaymentType.CARD) {
      throw new BadRequestException(`Payment type ${paymentMethod.type} is not supported for addCreditCard`);
    }
    try {
      // To add payment method, we first need to tokenize the card
      // Token is only valid for 15 mins
      const token = await this.checkoutApi.tokens.request({
        type: "card",
        number: paymentMethod.cardDetails.cardNumber,
        expiry_month: paymentMethod.cardDetails.expiryMonth,
        expiry_year: paymentMethod.cardDetails.expiryYear,
        cvv: paymentMethod.cardDetails.cvv,
      });

      // Now create instrument
      const instrument = await this.checkoutApi.instruments.create({
        // infered type "token",
        token: token["token"], // Generated by Checkout.Frames
        customer: {
          id: checkoutCustomerID,
        },
      });
      console.log(instrument);
      return {
        instrumentID: instrument["id"],
        scheme: instrument["scheme"],
        bin: instrument["bin"],
        issuer: instrument["issuer"] ?? "",
        cardType: instrument["card_type"],
      };
    } catch (err) {
      this.logger.error(`Failed to add card card: ${err}`);
      throw new BadRequestException({ message: "Failed to add card" });
    }
  }

  public async getPaymentMethod(paymentMethodID: string): Promise<PspAddPaymentMethodResponse> {
    const paymentMethodResponse = await this.checkoutApi.instruments.get(paymentMethodID);

    return {
      instrumentID: paymentMethodID,
      scheme: paymentMethodResponse["scheme"],
      bin: paymentMethodResponse["bin"],
      issuer: paymentMethodResponse["issuer"] ?? "",
      cardType: paymentMethodResponse["card_type"],
    };
  }

  public async makeACHPayment(
    amount: number,
    currency: string,
    paymentMethodId: string,
    transactionId: string,
    consumer: Consumer,
    idempotencyKey: string,
  ): Promise<PspACHPaymentResponse> {
    try {
      const checkoutResponse = await this.checkoutApi.payments.request(
        {
          amount: amount,
          currency: currency,
          source: {
            type: "provider_token",
            payment_method: "ach",
            token: paymentMethodId,
            account_holder: {
              type: "individual",
              billing_address: {
                address_line_1: consumer.props.address.streetLine1,
                address_line_2: consumer.props.address.streetLine2,
                city: consumer.props.address.city,
                country: consumer.props.address.countryCode,
                state: consumer.props.address.regionCode,
                zip: consumer.props.address.postalCode,
              },
            },
          },
          description: "Noba Customer Payment at UTC " + Date.now(),
          processing_channel_id: this.checkoutConfigs.processingChannelId,
          metadata: {
            order_id: transactionId,
          },
          reference: transactionId,
        },
        idempotencyKey,
      );

      this.logger.info(`Response from Checkout: ${JSON.stringify(checkoutResponse, null, 1)}`);

      const status = checkoutResponse["status"];

      return {
        id: checkoutResponse["id"],
        status: status,
        response_code: checkoutResponse["responseCode"],
      };
    } catch (e) {
      this.logger.error(
        `Exception while requesting checkout payment for transaction id ${transactionId}: ${JSON.stringify(e)}`,
      );
      throw e;
    }
  }

  public async makeCardPayment(
    amount: number,
    currency: string,
    paymentMethodId: string,
    transactionId: string,
    consumer: Consumer,
    idempotencyKey: string,
  ): Promise<PspCardPaymentResponse> {
    try {
      const checkoutResponse = await this.checkoutApi.payments.request(
        {
          amount: amount,
          currency: currency,
          source: {
            type: "id",
            id: paymentMethodId,
          },
          description: "Noba Customer Payment at UTC " + Date.now(),
          processing_channel_id: this.checkoutConfigs.processingChannelId,
          metadata: {
            order_id: transactionId,
          },
          sender: {
            first_name: consumer.props.firstName,
            last_name: consumer.props.lastName,
            address: {
              address_line_1: consumer.props.address.streetLine1,
              address_line_2: consumer.props.address.streetLine2,
              city: consumer.props.address.city,
              country: consumer.props.address.countryCode,
              state: consumer.props.address.regionCode,
              zip: consumer.props.address.postalCode,
            },
          },
          reference: transactionId,
          reference_type: "other",
        },
        idempotencyKey,
      );
      return {
        id: checkoutResponse["id"],
        response_code: checkoutResponse["response_code"],
        response_summary: checkoutResponse["response_summary"],
        risk: {
          flagged: checkoutResponse["risk"]["flagged"],
        },
        bin: checkoutResponse["source"]["bin"],
      };
    } catch (err) {
      this.logger.error(
        `Exception while requesting checkout payment for transaction id ${transactionId}: ${JSON.stringify(err)}`,
      );
      throw err;
    }
  }

  public async getPaymentDetails(paymentId: string): Promise<CheckoutPaymentStatus> {
    try {
      const payment = await this.checkoutApi.payments.get(paymentId);
      const status: CheckoutPaymentStatus = payment.status;
      return status;
    } catch (err) {
      throw new BadRequestException("Error while checking payment status from payment id " + paymentId + " " + err);
    }
  }

  public async removePaymentMethod(paymentMethodId: string): Promise<void> {
    await this.checkoutApi.instruments.delete(paymentMethodId);
  }

  // This function doesn't take any parameters and is idempotent.
  // So, it is safe to expose it publicly as clients can't do much with it.
  public async registerACHWebhooks() {
    // TODO: Remove this once we have confidence in the flow.
    // url: "https://webhook.site/523c9bbe-7a61-423c-9d2e-62519d30bfdd",
    const webhookUrl = this.checkoutConfigs.nobaWebhookUrl;
    if (webhookUrl === "disabled") {
      this.logger.warn("Skipping Checkout ACH webhook registration");
      return;
    }

    try {
      const workflows: WorkflowMetadata[] = (
        await axios.get(`${this.checkoutConfigs.apiUrl}/workflows`, {
          headers: {
            Authorization: `Bearer ${this.checkoutConfigs.secretKey}`,
          },
        })
      ).data.data;

      let webhookAlreadyConfigured = false;
      workflows.forEach(workflow => {
        if (workflow.name.endsWith(webhookUrl)) {
          webhookAlreadyConfigured = true;
        }
      });
      if (webhookAlreadyConfigured) {
        console.log(`Workflow already configured - ${JSON.stringify(workflows)}`);
        return;
      }

      const createWorkflowRequest = {
        // The webhook URL is added in the "name" intentionally to save API calls.
        // Get All Wrokflow call above, doesn't return the webhook url
        // (You need to call GET /workflow with the specified ID for the same) but it does
        // returns the "name" for the webhook.
        name: `Webhook for ${webhookUrl}`,
        conditions: [
          {
            type: "event",
            events: {
              gateway: [
                // https://www.checkout-docs-private-beta.com/docs/four/ach#Webhooks
                "payment_pending",
                "payment_capture_pending",
                "payment_declined",
                "payment_captured",
                "payment_returned",
              ],
            },
          },
        ],
        actions: [
          {
            type: "webhook",
            url: webhookUrl,
            headers: {
              Authorization: "secret-key",
            },
            signature: {
              method: "HMACSHA256",
              key: this.checkoutConfigs.webhookSignatureKey,
            },
          },
        ],
      };
      const registeredWorkflowId = (
        await axios.post(`${this.checkoutConfigs.apiUrl}/workflows`, createWorkflowRequest, {
          headers: {
            Authorization: `Bearer ${this.checkoutConfigs.secretKey}`,
          },
        })
      ).data.id;
      console.log(`Workflow created with ID: '${registeredWorkflowId}'`);

      // const workflows: WorkflowMetadata[] = ((await this.checkoutApi.workflows.getAll()) as any).data;
      // if (workflows.length === 1) {
      //   // TODO: Extend this to support the workflow "update" case as well by
      //   //       having something like "desired_workflow" as private variable.
      //   this.logger.info(`Workflow already configured - ${JSON.stringify(workflows)}`);
      //   return;
      // }
      // console.log(workflows);
      // const webhookResponse = await this.checkoutApi.workflows.add(createWorkflowRequest);
      // console.log("Webhook created", webhookResponse);
    } catch (e) {
      console.log(e, e.response);
      throw e;
    }
  }
}
