import { Inject, Injectable } from "@nestjs/common";
import { Prisma } from "@prisma/client";
import { WINSTON_MODULE_PROVIDER } from "nest-winston";
import { PrismaService } from "../../../../infraproviders/PrismaService";
import { Logger } from "winston";
import { PomeloUser as PrismaPomeloUserModel } from "@prisma/client";
import {
  convertToDomainPomeloUser,
  PomeloUser,
  PomeloUserSaveRequest,
  validatePomeloUser,
  validateSavePomeloUserRequest,
} from "../domain/PomeloUser";
import { PomeloRepo } from "./pomelo.repo";
import { RepoErrorCode, RepoException } from "../../../../core/exception/repo.exception";

@Injectable()
export class SqlPomeloRepo implements PomeloRepo {
  constructor(
    private readonly prismaService: PrismaService,
    @Inject(WINSTON_MODULE_PROVIDER) private readonly logger: Logger,
  ) {}

  async createPomeloUser(request: PomeloUserSaveRequest): Promise<PomeloUser> {
    validateSavePomeloUserRequest(request);

    let savedPomeloUser: PomeloUser = null;

    try {
      // Note that "createdTimestamp", "updatedTimestamp" & "ID" are not included in the input.
      // They are automatically generated by the database.
      const pomeloUserInput: Prisma.PomeloUserCreateInput = {
        consumer: {
          connect: {
            id: request.consumerID,
          },
        },
        pomeloID: request.pomeloUserID,
      };

      const returnedPomeloUser: PrismaPomeloUserModel = await this.prismaService.pomeloUser.create({
        data: pomeloUserInput,
      });
      savedPomeloUser = convertToDomainPomeloUser(returnedPomeloUser);
    } catch (err) {
      this.logger.error(JSON.stringify(err));
      throw new RepoException({
        errorCode: RepoErrorCode.DATABASE_INTERNAL_ERROR,
        message: "Error saving transaction in database",
      });
    }

    try {
      validatePomeloUser(savedPomeloUser);
      return savedPomeloUser;
    } catch (err) {
      this.logger.error(JSON.stringify(err));
      throw new RepoException({
        errorCode: RepoErrorCode.INVALID_DATABASE_RECORD,
        message: "Invalid database record",
      });
    }
  }

  async getPomeloUserByConsumerID(consumerID: string): Promise<PomeloUser> {
    try {
      const returnedPomeloUser: PrismaPomeloUserModel = await this.prismaService.pomeloUser.findUnique({
        where: {
          consumerID: consumerID,
        },
      });

      if (!returnedPomeloUser) {
        return null;
      }

      return convertToDomainPomeloUser(returnedPomeloUser);
    } catch (err) {
      this.logger.error(JSON.stringify(err));
      throw new RepoException({
        errorCode: RepoErrorCode.DATABASE_INTERNAL_ERROR,
        message: `Error getting the Pomelo user with consumerID: '${consumerID}'`,
      });
    }
  }

  async getPomeloUserByPomeloID(pomeloUserID: string): Promise<PomeloUser> {
    try {
      const returnedPomeloUser: PrismaPomeloUserModel = await this.prismaService.pomeloUser.findUnique({
        where: {
          pomeloID: pomeloUserID,
        },
      });

      if (!returnedPomeloUser) {
        return null;
      }

      return convertToDomainPomeloUser(returnedPomeloUser);
    } catch (err) {
      this.logger.error(JSON.stringify(err));
      throw new RepoException({
        errorCode: RepoErrorCode.DATABASE_INTERNAL_ERROR,
        message: `Error getting the Pomelo user with pomeloUserID: '${pomeloUserID}'`,
      });
    }
  }
}
